"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AlreadyExistsError: () => AlreadyExistsError,
  Client: () => Client,
  ForbiddenError: () => ForbiddenError,
  InternalError: () => InternalError,
  InvalidDataFormatError: () => InvalidDataFormatError,
  InvalidIdentifierError: () => InvalidIdentifierError,
  InvalidJsonSchemaError: () => InvalidJsonSchemaError,
  InvalidPayloadError: () => InvalidPayloadError,
  InvalidQueryError: () => InvalidQueryError,
  LimitExceededError: () => LimitExceededError,
  MethodNotFoundError: () => MethodNotFoundError,
  PayloadTooLargeError: () => PayloadTooLargeError,
  PaymentRequiredError: () => PaymentRequiredError,
  QuotaExceededError: () => QuotaExceededError,
  RateLimitedError: () => RateLimitedError,
  ReferenceNotFoundError: () => ReferenceNotFoundError,
  RelationConflictError: () => RelationConflictError,
  ResourceNotFoundError: () => ResourceNotFoundError,
  RuntimeError: () => RuntimeError,
  UnauthorizedError: () => UnauthorizedError,
  UnknownError: () => UnknownError,
  UnsupportedMediaTypeError: () => UnsupportedMediaTypeError,
  axios: () => axios3,
  errorFrom: () => errorFrom,
  isApiError: () => isApiError
});
module.exports = __toCommonJS(src_exports);
var import_browser_or_node2 = require("browser-or-node");
var import_axios4 = __toESM(require("axios"));

// src/gen/client/client.ts
var import_axios3 = __toESM(require("axios"));

// src/gen/client/api.ts
var import_axios2 = __toESM(require("axios"));

// src/gen/client/base.ts
var import_axios = __toESM(require("axios"));
var BASE_PATH = "https://api.botpress.cloud/webhooks".replace(/\/+$/, "");
var BaseAPI = class {
  constructor(configuration, basePath = BASE_PATH, axios4 = import_axios.default) {
    this.basePath = basePath;
    this.axios = axios4;
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
  configuration;
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};

// src/gen/client/common.ts
var DUMMY_BASE_URL = "https://example.com";
var assertParamExists = function(functionName, paramName, paramValue) {
  if (paramValue === null || paramValue === void 0) {
    throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
  }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
  if (parameter == null)
    return;
  if (typeof parameter === "object") {
    if (Array.isArray(parameter)) {
      parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
    } else {
      Object.keys(parameter).forEach(
        (currentKey) => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== "" ? "." : ""}${currentKey}`)
      );
    }
  } else {
    if (urlSearchParams.has(key)) {
      urlSearchParams.append(key, parameter);
    } else {
      urlSearchParams.set(key, parameter);
    }
  }
}
var setSearchParams = function(url, ...objects) {
  const searchParams = new URLSearchParams(url.search);
  setFlattenedQueryParams(searchParams, objects);
  url.search = searchParams.toString();
};
var serializeDataIfNeeded = function(value, requestOptions, configuration) {
  const nonString = typeof value !== "string";
  const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
  return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || "";
};
var toPathString = function(url) {
  return url.pathname + url.search + url.hash;
};
var createRequestFunction = function(axiosArgs, globalAxios3, BASE_PATH2, configuration) {
  return (axios4 = globalAxios3, basePath = BASE_PATH2) => {
    const axiosRequestArgs = { ...axiosArgs.options, url: (configuration?.basePath || basePath) + axiosArgs.url };
    return axios4.request(axiosRequestArgs);
  };
};

// src/gen/client/api.ts
var DefaultApiAxiosParamCreator = function(configuration) {
  return {
    addParticipant: async (xChatKey, id, addParticipantBody, options = {}) => {
      assertParamExists("addParticipant", "xChatKey", xChatKey);
      assertParamExists("addParticipant", "id", id);
      const localVarPath = `/v1/conversations/{id}/participants`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(addParticipantBody, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    createConversation: async (xChatKey, createConversationBody, options = {}) => {
      assertParamExists("createConversation", "xChatKey", xChatKey);
      const localVarPath = `/v1/conversations`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createConversationBody, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    createMessage: async (xChatKey, createMessageBody, options = {}) => {
      assertParamExists("createMessage", "xChatKey", xChatKey);
      const localVarPath = `/v1/messages`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createMessageBody, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    createUser: async (createUserBody, options = {}) => {
      const localVarPath = `/v1/users`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createUserBody, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    deleteConversation: async (xChatKey, id, options = {}) => {
      assertParamExists("deleteConversation", "xChatKey", xChatKey);
      assertParamExists("deleteConversation", "id", id);
      const localVarPath = `/v1/conversations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    deleteMessage: async (xChatKey, id, options = {}) => {
      assertParamExists("deleteMessage", "xChatKey", xChatKey);
      assertParamExists("deleteMessage", "id", id);
      const localVarPath = `/v1/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    deleteUser: async (xChatKey, options = {}) => {
      assertParamExists("deleteUser", "xChatKey", xChatKey);
      const localVarPath = `/v1/users/me`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    getConversation: async (xChatKey, id, options = {}) => {
      assertParamExists("getConversation", "xChatKey", xChatKey);
      assertParamExists("getConversation", "id", id);
      const localVarPath = `/v1/conversations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    getMessage: async (xChatKey, id, options = {}) => {
      assertParamExists("getMessage", "xChatKey", xChatKey);
      assertParamExists("getMessage", "id", id);
      const localVarPath = `/v1/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    getOrCreateConversation: async (xChatKey, getOrCreateConversationBody, options = {}) => {
      assertParamExists("getOrCreateConversation", "xChatKey", xChatKey);
      const localVarPath = `/v1/conversations/get-or-create`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(getOrCreateConversationBody, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    getOrCreateMessage: async (xChatKey, getOrCreateMessageBody, options = {}) => {
      assertParamExists("getOrCreateMessage", "xChatKey", xChatKey);
      const localVarPath = `/v1/messages/get-or-create`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(getOrCreateMessageBody, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    getParticipant: async (xChatKey, id, userId, options = {}) => {
      assertParamExists("getParticipant", "xChatKey", xChatKey);
      assertParamExists("getParticipant", "id", id);
      assertParamExists("getParticipant", "userId", userId);
      const localVarPath = `/v1/conversations/{id}/participants/{userId}`.replace(`{${"id"}}`, encodeURIComponent(String(id))).replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    getUser: async (xChatKey, options = {}) => {
      assertParamExists("getUser", "xChatKey", xChatKey);
      const localVarPath = `/v1/users/me`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    listConversationMessages: async (xChatKey, id, nextToken, options = {}) => {
      assertParamExists("listConversationMessages", "xChatKey", xChatKey);
      assertParamExists("listConversationMessages", "id", id);
      const localVarPath = `/v1/conversations/{id}/messages`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (nextToken !== void 0) {
        localVarQueryParameter["nextToken"] = nextToken;
      }
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    listConversations: async (xChatKey, nextToken, options = {}) => {
      assertParamExists("listConversations", "xChatKey", xChatKey);
      const localVarPath = `/v1/conversations`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (nextToken !== void 0) {
        localVarQueryParameter["nextToken"] = nextToken;
      }
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    listParticipants: async (xChatKey, id, nextToken, options = {}) => {
      assertParamExists("listParticipants", "xChatKey", xChatKey);
      assertParamExists("listParticipants", "id", id);
      const localVarPath = `/v1/conversations/{id}/participants`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (nextToken !== void 0) {
        localVarQueryParameter["nextToken"] = nextToken;
      }
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    listenConversation: async (xChatKey, id, options = {}) => {
      assertParamExists("listenConversation", "xChatKey", xChatKey);
      assertParamExists("listenConversation", "id", id);
      const localVarPath = `/v1/conversations/{id}/listen`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    removeParticipant: async (xChatKey, id, userId, options = {}) => {
      assertParamExists("removeParticipant", "xChatKey", xChatKey);
      assertParamExists("removeParticipant", "id", id);
      assertParamExists("removeParticipant", "userId", userId);
      const localVarPath = `/v1/conversations/{id}/participants/{userId}`.replace(`{${"id"}}`, encodeURIComponent(String(id))).replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    updateConversation: async (xChatKey, id, updateConversationBody, options = {}) => {
      assertParamExists("updateConversation", "xChatKey", xChatKey);
      assertParamExists("updateConversation", "id", id);
      const localVarPath = `/v1/conversations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateConversationBody, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    updateMessage: async (xChatKey, id, updateMessageBody, options = {}) => {
      assertParamExists("updateMessage", "xChatKey", xChatKey);
      assertParamExists("updateMessage", "id", id);
      const localVarPath = `/v1/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateMessageBody, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    updateUser: async (xChatKey, updateUserBody, options = {}) => {
      assertParamExists("updateUser", "xChatKey", xChatKey);
      const localVarPath = `/v1/users/me`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (xChatKey != null) {
        localVarHeaderParameter["x-chat-key"] = String(xChatKey);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateUserBody, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var DefaultApiFp = function(configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    async addParticipant(xChatKey, id, addParticipantBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addParticipant(xChatKey, id, addParticipantBody, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async createConversation(xChatKey, createConversationBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createConversation(xChatKey, createConversationBody, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async createMessage(xChatKey, createMessageBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createMessage(xChatKey, createMessageBody, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async createUser(createUserBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserBody, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async deleteConversation(xChatKey, id, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversation(xChatKey, id, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async deleteMessage(xChatKey, id, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(xChatKey, id, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async deleteUser(xChatKey, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(xChatKey, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async getConversation(xChatKey, id, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConversation(xChatKey, id, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async getMessage(xChatKey, id, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMessage(xChatKey, id, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async getOrCreateConversation(xChatKey, getOrCreateConversationBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOrCreateConversation(xChatKey, getOrCreateConversationBody, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async getOrCreateMessage(xChatKey, getOrCreateMessageBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOrCreateMessage(xChatKey, getOrCreateMessageBody, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async getParticipant(xChatKey, id, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getParticipant(xChatKey, id, userId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async getUser(xChatKey, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(xChatKey, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async listConversationMessages(xChatKey, id, nextToken, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listConversationMessages(xChatKey, id, nextToken, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async listConversations(xChatKey, nextToken, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listConversations(xChatKey, nextToken, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async listParticipants(xChatKey, id, nextToken, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listParticipants(xChatKey, id, nextToken, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async listenConversation(xChatKey, id, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listenConversation(xChatKey, id, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async removeParticipant(xChatKey, id, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeParticipant(xChatKey, id, userId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async updateConversation(xChatKey, id, updateConversationBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateConversation(xChatKey, id, updateConversationBody, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async updateMessage(xChatKey, id, updateMessageBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateMessage(xChatKey, id, updateMessageBody, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    async updateUser(xChatKey, updateUserBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(xChatKey, updateUserBody, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    }
  };
};
var DefaultApi = class extends BaseAPI {
  addParticipant(requestParameters, options) {
    return DefaultApiFp(this.configuration).addParticipant(requestParameters.xChatKey, requestParameters.id, requestParameters.addParticipantBody, options).then((request) => request(this.axios, this.basePath));
  }
  createConversation(requestParameters, options) {
    return DefaultApiFp(this.configuration).createConversation(requestParameters.xChatKey, requestParameters.createConversationBody, options).then((request) => request(this.axios, this.basePath));
  }
  createMessage(requestParameters, options) {
    return DefaultApiFp(this.configuration).createMessage(requestParameters.xChatKey, requestParameters.createMessageBody, options).then((request) => request(this.axios, this.basePath));
  }
  createUser(requestParameters = {}, options) {
    return DefaultApiFp(this.configuration).createUser(requestParameters.createUserBody, options).then((request) => request(this.axios, this.basePath));
  }
  deleteConversation(requestParameters, options) {
    return DefaultApiFp(this.configuration).deleteConversation(requestParameters.xChatKey, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
  }
  deleteMessage(requestParameters, options) {
    return DefaultApiFp(this.configuration).deleteMessage(requestParameters.xChatKey, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
  }
  deleteUser(requestParameters, options) {
    return DefaultApiFp(this.configuration).deleteUser(requestParameters.xChatKey, options).then((request) => request(this.axios, this.basePath));
  }
  getConversation(requestParameters, options) {
    return DefaultApiFp(this.configuration).getConversation(requestParameters.xChatKey, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
  }
  getMessage(requestParameters, options) {
    return DefaultApiFp(this.configuration).getMessage(requestParameters.xChatKey, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
  }
  getOrCreateConversation(requestParameters, options) {
    return DefaultApiFp(this.configuration).getOrCreateConversation(requestParameters.xChatKey, requestParameters.getOrCreateConversationBody, options).then((request) => request(this.axios, this.basePath));
  }
  getOrCreateMessage(requestParameters, options) {
    return DefaultApiFp(this.configuration).getOrCreateMessage(requestParameters.xChatKey, requestParameters.getOrCreateMessageBody, options).then((request) => request(this.axios, this.basePath));
  }
  getParticipant(requestParameters, options) {
    return DefaultApiFp(this.configuration).getParticipant(requestParameters.xChatKey, requestParameters.id, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
  }
  getUser(requestParameters, options) {
    return DefaultApiFp(this.configuration).getUser(requestParameters.xChatKey, options).then((request) => request(this.axios, this.basePath));
  }
  listConversationMessages(requestParameters, options) {
    return DefaultApiFp(this.configuration).listConversationMessages(requestParameters.xChatKey, requestParameters.id, requestParameters.nextToken, options).then((request) => request(this.axios, this.basePath));
  }
  listConversations(requestParameters, options) {
    return DefaultApiFp(this.configuration).listConversations(requestParameters.xChatKey, requestParameters.nextToken, options).then((request) => request(this.axios, this.basePath));
  }
  listParticipants(requestParameters, options) {
    return DefaultApiFp(this.configuration).listParticipants(requestParameters.xChatKey, requestParameters.id, requestParameters.nextToken, options).then((request) => request(this.axios, this.basePath));
  }
  listenConversation(requestParameters, options) {
    return DefaultApiFp(this.configuration).listenConversation(requestParameters.xChatKey, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
  }
  removeParticipant(requestParameters, options) {
    return DefaultApiFp(this.configuration).removeParticipant(requestParameters.xChatKey, requestParameters.id, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
  }
  updateConversation(requestParameters, options) {
    return DefaultApiFp(this.configuration).updateConversation(requestParameters.xChatKey, requestParameters.id, requestParameters.updateConversationBody, options).then((request) => request(this.axios, this.basePath));
  }
  updateMessage(requestParameters, options) {
    return DefaultApiFp(this.configuration).updateMessage(requestParameters.xChatKey, requestParameters.id, requestParameters.updateMessageBody, options).then((request) => request(this.axios, this.basePath));
  }
  updateUser(requestParameters, options) {
    return DefaultApiFp(this.configuration).updateUser(requestParameters.xChatKey, requestParameters.updateUserBody, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/gen/client/errors.ts
var import_crypto = __toESM(require("crypto"));
var cryptoLibPolyfill = {
  getRandomValues: (array) => new Uint8Array(array.map(() => Math.floor(Math.random() * 256)))
};
var cryptoLib = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.crypto : import_crypto.default;
if (!cryptoLib.getRandomValues) {
  cryptoLib = cryptoLibPolyfill;
}
var BaseApiError = class extends Error {
  constructor(code, description, type, message, error, id) {
    super(message);
    this.code = code;
    this.description = description;
    this.type = type;
    this.message = message;
    this.error = error;
    this.id = id;
    if (!this.id) {
      this.id = BaseApiError.generateId();
    }
  }
  isApiError = true;
  format() {
    return `[${this.type}] ${this.message} (Error ID: ${this.id})`;
  }
  toJSON() {
    return {
      id: this.id,
      code: this.code,
      type: this.type,
      message: this.message
    };
  }
  static generateId() {
    const randomSuffixByteLength = 4;
    const randomHexSuffix = Array.from(cryptoLib.getRandomValues(new Uint8Array(randomSuffixByteLength))).map((x) => x.toString(16).padStart(2, "0")).join("").toUpperCase();
    return `err_${Date.now()}x${randomHexSuffix}`;
  }
};
var isObject = (obj) => typeof obj === "object" && !Array.isArray(obj) && obj !== null;
var isApiError = (thrown) => {
  return thrown instanceof BaseApiError || isObject(thrown) && thrown.isApiError === true;
};
var UnknownError = class extends BaseApiError {
  constructor(message, error, id) {
    super(500, "An unknown error occurred", "Unknown", message, error, id);
  }
};
var InternalError = class extends BaseApiError {
  constructor(message, error, id) {
    super(500, "An internal error occurred", "Internal", message, error, id);
  }
};
var UnauthorizedError = class extends BaseApiError {
  constructor(message, error, id) {
    super(401, "The request requires to be authenticated.", "Unauthorized", message, error, id);
  }
};
var ForbiddenError = class extends BaseApiError {
  constructor(message, error, id) {
    super(403, "The requested action can't be peform by this resource.", "Forbidden", message, error, id);
  }
};
var PayloadTooLargeError = class extends BaseApiError {
  constructor(message, error, id) {
    super(413, "The request payload is too large.", "PayloadTooLarge", message, error, id);
  }
};
var InvalidPayloadError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The request payload is invalid.", "InvalidPayload", message, error, id);
  }
};
var UnsupportedMediaTypeError = class extends BaseApiError {
  constructor(message, error, id) {
    super(415, "The request is invalid because the content-type is not supported.", "UnsupportedMediaType", message, error, id);
  }
};
var MethodNotFoundError = class extends BaseApiError {
  constructor(message, error, id) {
    super(405, "The requested method does not exist.", "MethodNotFound", message, error, id);
  }
};
var ResourceNotFoundError = class extends BaseApiError {
  constructor(message, error, id) {
    super(404, "The requested resource does not exist.", "ResourceNotFound", message, error, id);
  }
};
var InvalidJsonSchemaError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided JSON schema is invalid.", "InvalidJsonSchema", message, error, id);
  }
};
var InvalidDataFormatError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided data doesn't respect the provided JSON schema.", "InvalidDataFormat", message, error, id);
  }
};
var InvalidIdentifierError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.", "InvalidIdentifier", message, error, id);
  }
};
var RelationConflictError = class extends BaseApiError {
  constructor(message, error, id) {
    super(409, "The resource is not related with another resource. This is usually caused when providing two resources that aren't linked together.", "RelationConflict", message, error, id);
  }
};
var ReferenceNotFoundError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.", "ReferenceNotFound", message, error, id);
  }
};
var InvalidQueryError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.", "InvalidQuery", message, error, id);
  }
};
var RuntimeError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "An error happened during the execution of a runtime (bot or integration).", "Runtime", message, error, id);
  }
};
var AlreadyExistsError = class extends BaseApiError {
  constructor(message, error, id) {
    super(409, "The record attempted to be created already exists.", "AlreadyExists", message, error, id);
  }
};
var RateLimitedError = class extends BaseApiError {
  constructor(message, error, id) {
    super(429, "The request has been rate limited.", "RateLimited", message, error, id);
  }
};
var PaymentRequiredError = class extends BaseApiError {
  constructor(message, error, id) {
    super(402, "A payment is required to perform this request.", "PaymentRequired", message, error, id);
  }
};
var QuotaExceededError = class extends BaseApiError {
  constructor(message, error, id) {
    super(403, "The request exceeds the allowed quota. Quotas are a soft limit that can be increased.", "QuotaExceeded", message, error, id);
  }
};
var LimitExceededError = class extends BaseApiError {
  constructor(message, error, id) {
    super(413, "The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.", "LimitExceeded", message, error, id);
  }
};
var errorTypes = {
  Unknown: UnknownError,
  Internal: InternalError,
  Unauthorized: UnauthorizedError,
  Forbidden: ForbiddenError,
  PayloadTooLarge: PayloadTooLargeError,
  InvalidPayload: InvalidPayloadError,
  UnsupportedMediaType: UnsupportedMediaTypeError,
  MethodNotFound: MethodNotFoundError,
  ResourceNotFound: ResourceNotFoundError,
  InvalidJsonSchema: InvalidJsonSchemaError,
  InvalidDataFormat: InvalidDataFormatError,
  InvalidIdentifier: InvalidIdentifierError,
  RelationConflict: RelationConflictError,
  ReferenceNotFound: ReferenceNotFoundError,
  InvalidQuery: InvalidQueryError,
  Runtime: RuntimeError,
  AlreadyExists: AlreadyExistsError,
  RateLimited: RateLimitedError,
  PaymentRequired: PaymentRequiredError,
  QuotaExceeded: QuotaExceededError,
  LimitExceeded: LimitExceededError
};
var errorFrom = (err) => {
  if (isApiError(err)) {
    return err;
  } else if (err instanceof Error) {
    return new UnknownError(err.message, err);
  } else if (typeof err === "string") {
    return new UnknownError(err);
  } else {
    return getApiErrorFromObject(err);
  }
};
function getApiErrorFromObject(err) {
  if (typeof err === "object" && "code" in err && "type" in err && "id" in err && "message" in err && typeof err.type === "string" && typeof err.message === "string") {
    const ErrorClass = errorTypes[err.type];
    if (!ErrorClass) {
      return new UnknownError(`An unclassified API error occurred: ${err.message} (Type: ${err.type}, Code: ${err.code})`);
    }
    return new ErrorClass(err.message, void 0, err.id || "UNKNOWN");
  }
  return new UnknownError("An invalid error occurred: " + JSON.stringify(err));
}

// src/gen/client/client.ts
var ApiClient = class {
  _innerClient;
  constructor(configuration, basePath, axiosInstance) {
    this._innerClient = new DefaultApi(configuration, basePath, axiosInstance);
  }
  getConversation = (props) => this._innerClient.getConversation(props).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  createConversation = ({ xChatKey, ...createConversationBody }) => this._innerClient.createConversation({ xChatKey, createConversationBody }).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  getOrCreateConversation = ({ xChatKey, ...getOrCreateConversationBody }) => this._innerClient.getOrCreateConversation({ xChatKey, getOrCreateConversationBody }).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  updateConversation = ({ id, xChatKey, ...updateConversationBody }) => this._innerClient.updateConversation({ id, xChatKey, updateConversationBody }).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  deleteConversation = (props) => this._innerClient.deleteConversation(props).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  listConversations = (props) => this._innerClient.listConversations(props).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  listenConversation = (props) => this._innerClient.listenConversation(props).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  listConversationMessages = (props) => this._innerClient.listConversationMessages(props).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  addParticipant = ({ id, xChatKey, ...addParticipantBody }) => this._innerClient.addParticipant({ id, xChatKey, addParticipantBody }).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  removeParticipant = (props) => this._innerClient.removeParticipant(props).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  getParticipant = (props) => this._innerClient.getParticipant(props).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  listParticipants = (props) => this._innerClient.listParticipants(props).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  getMessage = (props) => this._innerClient.getMessage(props).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  createMessage = ({ xChatKey, ...createMessageBody }) => this._innerClient.createMessage({ xChatKey, createMessageBody }).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  getOrCreateMessage = ({ xChatKey, ...getOrCreateMessageBody }) => this._innerClient.getOrCreateMessage({ xChatKey, getOrCreateMessageBody }).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  updateMessage = ({ id, xChatKey, ...updateMessageBody }) => this._innerClient.updateMessage({ id, xChatKey, updateMessageBody }).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  deleteMessage = (props) => this._innerClient.deleteMessage(props).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  getUser = (props) => this._innerClient.getUser(props).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  createUser = (createUserBody) => this._innerClient.createUser({ createUserBody }).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  updateUser = ({ xChatKey, ...updateUserBody }) => this._innerClient.updateUser({ xChatKey, updateUserBody }).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
  deleteUser = (props) => this._innerClient.deleteUser(props).then((res) => res.data).catch((e) => {
    throw getError(e);
  });
};
function getError(err) {
  if (import_axios3.default.isAxiosError(err) && err.response?.data) {
    return errorFrom(err.response.data);
  }
  return errorFrom(err);
}

// src/event-emitter.ts
var EventEmitter = class {
  listeners = {};
  emit(type, event) {
    const listeners = this.listeners[type];
    if (!listeners) {
      return;
    }
    for (const listener of [...listeners]) {
      listener(event);
    }
  }
  onceOrMore(type, listener) {
    const wrapped = (event) => {
      const status = listener(event);
      if (status === "stop-listening") {
        this.off(type, wrapped);
      }
    };
    this.on(type, wrapped);
  }
  once(type, listener) {
    const wrapped = (event) => {
      this.off(type, wrapped);
      listener(event);
    };
    this.on(type, wrapped);
  }
  on(type, listener) {
    if (!this.listeners[type]) {
      this.listeners[type] = [];
    }
    this.listeners[type].push(listener);
  }
  off(type, listener) {
    const listeners = this.listeners[type];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
  }
  cleanup() {
    this.listeners = {};
  }
};

// src/eventsource.ts
var import_browser_or_node = require("browser-or-node");
var makeEventSource = (url, props = {}) => {
  if (import_browser_or_node.isBrowser) {
    const module2 = require("event-source-polyfill");
    const ctor = module2.EventSourcePolyfill;
    const source = new ctor(url, { headers: props.headers });
    const emitter = new EventEmitter();
    source.onopen = (ev) => emitter.emit("open", ev);
    source.onmessage = (ev) => emitter.emit("message", ev);
    source.onerror = (ev) => emitter.emit("error", ev);
    return {
      emitter,
      source
    };
  } else {
    const module2 = require("eventsource");
    const source = new module2(url, { headers: props.headers });
    const emitter = new EventEmitter();
    source.onopen = (ev) => emitter.emit("open", ev);
    source.onmessage = (ev) => emitter.emit("message", ev);
    source.onerror = (ev) => emitter.emit("error", ev);
    return {
      emitter,
      source
    };
  }
};
var listenEventSource = async (url, props = {}) => {
  const { emitter, source } = makeEventSource(url, props);
  await new Promise((resolve, reject) => {
    emitter.on("open", () => {
      resolve();
    });
    emitter.on("error", (thrown) => {
      reject(thrown);
    });
  }).finally(() => emitter.cleanup());
  return {
    on: emitter.on.bind(emitter),
    close: () => {
      emitter.cleanup();
      source.close();
    }
  };
};

// src/gen/signals/messageCreatedSignal.z.ts
var import_zod = require("zod");
var messageCreatedSignal_z_default = import_zod.z.object({
  type: import_zod.z.literal("message_created"),
  data: import_zod.z.object({
    id: import_zod.z.string(),
    fid: import_zod.z.string().optional(),
    createdAt: import_zod.z.string().datetime(),
    payload: import_zod.z.union([
      import_zod.z.object({
        type: import_zod.z.literal("button"),
        variant: import_zod.z.enum(["action", "link"]),
        reusable: import_zod.z.boolean().optional(),
        groupId: import_zod.z.string().optional(),
        text: import_zod.z.string(),
        buttonValue: import_zod.z.string()
      }),
      import_zod.z.object({ type: import_zod.z.literal("text"), text: import_zod.z.string() }),
      import_zod.z.object({
        type: import_zod.z.literal("image"),
        orientation: import_zod.z.enum(["portrait", "landscape", "square", "auto"]).optional(),
        url: import_zod.z.string()
      }),
      import_zod.z.object({ type: import_zod.z.literal("audio"), url: import_zod.z.string() }),
      import_zod.z.object({ type: import_zod.z.literal("video"), url: import_zod.z.string() }),
      import_zod.z.object({
        type: import_zod.z.literal("file"),
        url: import_zod.z.string(),
        title: import_zod.z.string().optional()
      }),
      import_zod.z.object({
        type: import_zod.z.literal("location"),
        latitude: import_zod.z.number(),
        longitude: import_zod.z.number(),
        title: import_zod.z.string().optional()
      }),
      import_zod.z.object({
        type: import_zod.z.literal("custom"),
        payload: import_zod.z.object({}).catchall(import_zod.z.any())
      })
    ]),
    userId: import_zod.z.string(),
    conversationId: import_zod.z.string()
  })
});

// src/gen/signals/index.ts
var zod = {
  messageCreatedSignal: messageCreatedSignal_z_default
};

// src/signal-listener.ts
var DEFAULT_ERROR_MESSAGE = "unknown error";
var _SignalListener = class extends EventEmitter {
  constructor(_props) {
    super();
    this._props = _props;
  }
  _state = { status: "disconnected" };
  get status() {
    return this._state.status;
  }
  connect = async () => {
    if (this._state.status === "connected") {
      return;
    }
    if (this._state.status === "connecting") {
      await this._state.connectionPromise;
      return;
    }
    const connectionPromise = this._connect();
    this._state = { status: "connecting", connectionPromise };
    await connectionPromise;
  };
  disconnect = async () => {
    if (this._state.status === "disconnected") {
      return;
    }
    let source;
    if (this._state.status === "connecting") {
      source = await this._state.connectionPromise;
    } else {
      source = this._state.source;
    }
    this._disconnectSync(source);
  };
  _connect = async () => {
    const source = await listenEventSource(`${this._props.url}/v1/conversations/${this._props.conversationId}/listen`, {
      headers: { "x-chat-key": this._props.chatKey }
    });
    source.on("message", this._handleMessage);
    source.on("error", this._handleError(source));
    this._state = { status: "connected", source };
    return source;
  };
  _disconnectSync = (source) => {
    source.close();
    this._state = { status: "disconnected" };
  };
  _handleMessage = (ev) => {
    const signal = this._parseSignal(ev.data);
    this.emit(signal.type, signal.data);
  };
  _handleError = (source) => (ev) => {
    this._disconnectSync(source);
    const err = this._toError(ev);
    this.emit("error", err);
  };
  _parseSignal = (data) => {
    for (const schema of Object.values(zod)) {
      const parsedData = this._safeJsonParse(data);
      const parseResult = schema.safeParse(parsedData);
      if (parseResult.success) {
        return parseResult.data;
      }
    }
    return {
      type: "unknown",
      data
    };
  };
  _safeJsonParse = (x) => {
    try {
      return JSON.parse(x);
    } catch {
      return x;
    }
  };
  _toError = (thrown) => {
    if (thrown instanceof Error) {
      return thrown;
    }
    if (typeof thrown === "string") {
      return new Error(thrown);
    }
    if (thrown === null) {
      return new Error(DEFAULT_ERROR_MESSAGE);
    }
    if (typeof thrown === "object" && "message" in thrown) {
      return this._toError(thrown.message);
    }
    try {
      const json = JSON.stringify(thrown);
      return new Error(json);
    } catch {
      return new Error(DEFAULT_ERROR_MESSAGE);
    }
  };
};
var SignalListener = _SignalListener;
__publicField(SignalListener, "listen", async (props) => {
  const inst = new _SignalListener(props);
  await inst.connect();
  return inst;
});

// src/index.ts
var axios3 = __toESM(require("axios"));
var _100mb = 100 * 1024 * 1024;
var maxBodyLength = _100mb;
var maxContentLength = _100mb;
var defaultTimeout = 6e4;
var _Client = class {
  constructor(props) {
    this.props = props;
    const { apiUrl } = props;
    const axiosClient = _Client._createAxios(props);
    this._auto = new ApiClient(void 0, apiUrl, axiosClient);
  }
  _auto;
  createConversation = (x) => this._auto.createConversation(x);
  getConversation = (x) => this._auto.getConversation(x);
  getOrCreateConversation = (x) => this._auto.getOrCreateConversation(x);
  updateConversation = (x) => this._auto.updateConversation(x);
  deleteConversation = (x) => this._auto.deleteConversation(x);
  listConversations = (x) => this._auto.listConversations(x);
  listConversationMessages = (x) => this._auto.listConversationMessages(x);
  addParticipant = (x) => this._auto.addParticipant(x);
  removeParticipant = (x) => this._auto.removeParticipant(x);
  getParticipant = (x) => this._auto.getParticipant(x);
  listParticipants = (x) => this._auto.listParticipants(x);
  createMessage = (x) => this._auto.createMessage(x);
  getMessage = (x) => this._auto.getMessage(x);
  getOrCreateMessage = (x) => this._auto.getOrCreateMessage(x);
  updateMessage = (x) => this._auto.updateMessage(x);
  deleteMessage = (x) => this._auto.deleteMessage(x);
  createUser = (x) => this._auto.createUser(x);
  getUser = (x) => this._auto.getUser(x);
  updateUser = (x) => this._auto.updateUser(x);
  deleteUser = (x) => this._auto.deleteUser(x);
  listenConversation = async ({ id, xChatKey }) => {
    const signalListener = await SignalListener.listen({
      url: this.props.apiUrl,
      conversationId: id,
      chatKey: xChatKey
    });
    return signalListener;
  };
};
var Client = _Client;
__publicField(Client, "_createAxios", (props) => {
  const headers = {
    ...props.headers
  };
  const timeout = props.timeout ?? defaultTimeout;
  const withCredentials = import_browser_or_node2.isBrowser;
  return import_axios4.default.create({ headers, withCredentials, timeout, maxBodyLength, maxContentLength });
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AlreadyExistsError,
  Client,
  ForbiddenError,
  InternalError,
  InvalidDataFormatError,
  InvalidIdentifierError,
  InvalidJsonSchemaError,
  InvalidPayloadError,
  InvalidQueryError,
  LimitExceededError,
  MethodNotFoundError,
  PayloadTooLargeError,
  PaymentRequiredError,
  QuotaExceededError,
  RateLimitedError,
  ReferenceNotFoundError,
  RelationConflictError,
  ResourceNotFoundError,
  RuntimeError,
  UnauthorizedError,
  UnknownError,
  UnsupportedMediaTypeError,
  axios,
  errorFrom,
  isApiError
});
//# sourceMappingURL=index.cjs.map
